-- -------------------------------------------------------------
-- 
-- File Name: tp_vivado\hdlsrc\main\contador_mem_wr.vhd
-- Created: 2022-12-09 14:11:09
-- 
-- Generated by MATLAB 9.13 and HDL Coder 4.0
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: contador_mem_wr
-- Source Path: main/Subsystem/contador_mem_wr
-- Hierarchy Level: 1
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
USE work.Subsystem_pkg.ALL;

ENTITY contador_mem_wr IS
  PORT( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        enb                               :   IN    std_logic;
        sumar                             :   IN    std_logic;
        reset_1                           :   IN    std_logic;
        salida                            :   OUT   std_logic_vector(7 DOWNTO 0)  -- uint8
        );
END contador_mem_wr;


ARCHITECTURE rtl OF contador_mem_wr IS

  -- Functions
  -- HDLCODER_TO_STDLOGIC 
  FUNCTION hdlcoder_to_stdlogic(arg: boolean) RETURN std_logic IS
  BEGIN
    IF arg THEN
      RETURN '1';
    ELSE
      RETURN '0';
    END IF;
  END FUNCTION;


  -- Signals
  SIGNAL is_contador_mem_wr               : T_state_type_is_contador_mem_wr;  -- uint8
  SIGNAL salida_tmp                       : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL cont                             : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL temporalCounter_i1               : std_logic;  -- ufix1
  SIGNAL is_contador_mem_wr_next          : T_state_type_is_contador_mem_wr;  -- enum type state_type_is_contador_mem_wr (4 enums)
  SIGNAL cont_next                        : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL temporalCounter_i1_next          : std_logic;  -- ufix1

BEGIN
  contador_mem_wr_1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      temporalCounter_i1 <= '0';
      cont <= to_unsigned(16#00#, 8);
      is_contador_mem_wr <= IN_inicio;
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        is_contador_mem_wr <= is_contador_mem_wr_next;
        cont <= cont_next;
        temporalCounter_i1 <= temporalCounter_i1_next;
      END IF;
    END IF;
  END PROCESS contador_mem_wr_1_process;

  contador_mem_wr_1_output : PROCESS (cont, is_contador_mem_wr, reset_1, sumar, temporalCounter_i1)
    VARIABLE temporalCounter_i1_temp : std_logic;
    VARIABLE is_contador_mem_wr_temp : T_state_type_is_contador_mem_wr;
    VARIABLE cont_temp : unsigned(7 DOWNTO 0);
    VARIABLE add_cast : unsigned(1 DOWNTO 0);
    VARIABLE add_temp : unsigned(1 DOWNTO 0);
    VARIABLE add_temp_0 : unsigned(8 DOWNTO 0);
  BEGIN
    add_temp := to_unsigned(16#0#, 2);
    add_temp_0 := to_unsigned(16#000#, 9);
    add_cast := to_unsigned(16#0#, 2);
    cont_temp := cont;
    is_contador_mem_wr_temp := is_contador_mem_wr;
    temporalCounter_i1_temp := temporalCounter_i1;
    IF temporalCounter_i1 < '1' THEN 
      add_cast := '0' & temporalCounter_i1;
      add_temp := add_cast + to_unsigned(16#1#, 2);
      temporalCounter_i1_temp := add_temp(0);
    END IF;
    CASE is_contador_mem_wr IS
      WHEN IN_Espera =>
        NULL;
      WHEN IN_Reset =>
        cont_temp := to_unsigned(16#00#, 8);
      WHEN IN_incrementa =>
        NULL;
      WHEN OTHERS => 
        --case IN_inicio:
        cont_temp := to_unsigned(16#00#, 8);
    END CASE;
    CASE is_contador_mem_wr IS
      WHEN IN_Espera =>
        IF reset_1 = '1' THEN 
          is_contador_mem_wr_temp := IN_Reset;
          temporalCounter_i1_temp := '0';
        ELSIF sumar = '1' THEN 
          is_contador_mem_wr_temp := IN_incrementa;
          temporalCounter_i1_temp := '0';
        ELSE 
          is_contador_mem_wr_temp := IN_Espera;
        END IF;
      WHEN IN_Reset =>
        IF temporalCounter_i1_temp = '1' THEN 
          is_contador_mem_wr_temp := IN_Espera;
        END IF;
      WHEN IN_incrementa =>
        IF (reset_1 OR hdlcoder_to_stdlogic(cont_temp = to_unsigned(16#C7#, 8))) = '1' THEN 
          is_contador_mem_wr_temp := IN_Reset;
          temporalCounter_i1_temp := '0';
        ELSIF temporalCounter_i1_temp = '1' THEN 
          add_temp_0 := resize(cont_temp, 9) + to_unsigned(16#001#, 9);
          IF add_temp_0(8) /= '0' THEN 
            cont_temp := "11111111";
          ELSE 
            cont_temp := add_temp_0(7 DOWNTO 0);
          END IF;
          is_contador_mem_wr_temp := IN_Espera;
        END IF;
      WHEN OTHERS => 
        --case IN_inicio:
        is_contador_mem_wr_temp := IN_Espera;
    END CASE;
    cont_next <= cont_temp;
    is_contador_mem_wr_next <= is_contador_mem_wr_temp;
    temporalCounter_i1_next <= temporalCounter_i1_temp;
  END PROCESS contador_mem_wr_1_output;

  contador_mem_wr_1_output1 : PROCESS (cont, is_contador_mem_wr)
    VARIABLE salida1 : unsigned(7 DOWNTO 0);
  BEGIN
    salida1 := to_unsigned(16#00#, 8);
    CASE is_contador_mem_wr IS
      WHEN IN_Espera =>
        salida1 := cont;
      WHEN IN_Reset =>
        NULL;
      WHEN IN_incrementa =>
        salida1 := cont;
      WHEN OTHERS => 
        --case IN_inicio:
        NULL;
    END CASE;
    salida_tmp <= salida1;
  END PROCESS contador_mem_wr_1_output1;


  salida <= std_logic_vector(salida_tmp);

END rtl;

